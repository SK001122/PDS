package main

import (
	"bytes"
	"encoding/json"
        "strings"
        "fmt"
	"strconv"
	"time"

	"github.com/hyperledger/fabric/core/chaincode/shim"
	pb "github.com/hyperledger/fabric/protos/peer"
)

type jutebag_supplychain struct {
}

type CounterNO struct {
	Counter int `json:"counter"`
}

type User struct {
	Name      string `json:"Name"`
	User_Id   string `json:"UserId"`
	Email     string `json:"Email"`
	User_Type string `json:"UserType"`
	Address   string `json:"Address"`
	Password  string `json:"Password"`
}

type GeoLocation struct {
     latitude string `json:"latitude"`
     longitude string `json:"longitude"`
}
type JbAssetDates struct {
	OrderedDate           string `json:"OrderedDate"`
	ManufactureDate       string `json:"ManufactureDate"`
	SendToQCLoadingDate  string `json:"SendToQCLoadingDate"`
	SubmitQCReportLoadingDate  string `json:"SubmitQCReportLoadingDate"`
	HandoffToLogisticsDate string `json:"HandoffToLogisticsDate"`
	SendToQCUnloadingDate  string `json:"SendToQCUnloadingDate"`
	SubmitQCReportUnloadingDate  string `json:"SubmitQCReportUnloadingDate"`
	HandoffToWarehouseDate    string `json:"HandoffToWarehouseDate"`
	SendToRicemillDate    string `json:"SendToRicemillDate"`
	RicebagDeliveredDate         string `json:"RicebagDeliveredDate"` //Ricebag delivered to Warehouse
}
//Asset Jutebag as JbAsset
type JbAsset struct {
	JAsset_Id      string       `json:"JbAssetId"` // Autogenerated numbers blockchain side
	QRCode      string       `json:"QRCode"`//Generated by Jutemill
	Batch_No        string       `json:"BatchNo"`
	Order_No        string       `json:"OrderNo"`
	Asset_Name       string       `json:"AssetName"`
	Asset_Type       string       `json:"AssetType"`
	Jutemill string       `json:"Jutemill"`
	QCLstatus  string       `json:"QCLoading"` //user Id
	Logistics  string       `json:"Logistics"`
	QCUstatus   string       `json:"QCUnloading"` // User Id
	Warehouse     string       `json:"Warehouse"`
	Ricemill string `json:"Ricemill"` 
	Date            JbAssetDates `json:"Date"` 
	GeoLoc         GeoLocation `json:"GeoLoc"`
	Owner string  `json: "Owner"` 
	AssetStatus          string       `json:"AssetStatus"`
}

// ======================================= // Main // ====================================================

func main() {
	err := shim.Start(new(jutebag_supplychain))
	if err != nil {
		fmt.Printf("Error starting Simple chaincode: %s", err)
	}
}

// Init initializes chaincode // ===========================

func (t *jutebag_supplychain) Init(APIstub shim.ChaincodeStubInterface) pb.Response {

	// Initializing JbAsset Counter
	JbAssetCounterBytes, _ := APIstub.GetState("JbAssetCounterNO")
	if JbAssetCounterBytes == nil {
		var JbAssetCounter = CounterNO{Counter: 0}
		JbAssetCounterBytes, _ := json.Marshal(JbAssetCounter)
		err := APIstub.PutState("JbAssetCounterNO", JbAssetCounterBytes)
		if err != nil {
			return shim.Error(fmt.Sprintf("Failed to Intitate JbAsset Counter"))
		}
	}
	// Initializing Order Counter
	OrderCounterBytes, _ := APIstub.GetState("OrderCounterNO")
	if OrderCounterBytes == nil {
		var OrderCounter = CounterNO{Counter: 0}
		OrderCounterBytes, _ := json.Marshal(OrderCounter)
		err := APIstub.PutState("OrderCounterNO", OrderCounterBytes)
		if err != nil {
			return shim.Error(fmt.Sprintf("Failed to Intitate Order Counter"))
		}
	}
	// Initializing User Counter
	UserCounterBytes, _ := APIstub.GetState("UserCounterNO")
	if UserCounterBytes == nil {
		var UserCounter = CounterNO{Counter: 0}
		UserCounterBytes, _ := json.Marshal(UserCounter)
		err := APIstub.PutState("UserCounterNO", UserCounterBytes)
		if err != nil {
			return shim.Error(fmt.Sprintf("Failed to Intitate User Counter"))
		}
	}

	return shim.Success(nil)
}

// Invoke - Our entry point for Invocations // ========================================

func (t *jutebag_supplychain) Invoke(stub shim.ChaincodeStubInterface) pb.Response {
	function, args := stub.GetFunctionAndParameters()
	fmt.Println("invoke is running " + function)

	// Handle different functions phase 1: happy path
	// 1.createAsset, 2.UpdateAsseta, 3.queryAllAssets,4.queryAsset
	if function == "initLedger" {
		//init ledger
		return t.initLedger(stub, args)
	} else if function == "signIn" {
		//login user
		return t.signIn(stub, args)
	} else if function == "createUser" {
		//create a new user
		return t.createUser(stub, args)
	} else if function == "createJbAsset" {
		//create a new jBagAsset
		return t.createJbAsset(stub, args)
	} else if function == "updateJbAsset" {
		// update a jBagAsset
		return t.updateJbAsset(stub, args)
	} else if function == "queryAsset" {
		// query any using asset-id
		return t.queryAsset(stub, args)
	} else if function == "queryAllAssets" {
		// query all assests of a type
		return t.queryAllAssets(stub, args)
	} else if function == "queryAllUsers" {
		// query all assests of a type
		return t.queryAllUsers(stub, args)
	}
	fmt.Println("invoke did not find func: " + function)
	//error
	return shim.Error("Received unknown function invocation")
}

// Private function

//getCounter to the latest value of the counter based on the Asset Type provided as input parameter
func getCounter(APIstub shim.ChaincodeStubInterface, AssetType string) int {
	counterAsBytes, _ := APIstub.GetState(AssetType)
	counterAsset := CounterNO{}

	json.Unmarshal(counterAsBytes, &counterAsset)
	fmt.Sprintf("Counter Current Value %d of Asset Type %s", counterAsset.Counter, AssetType)

	return counterAsset.Counter
}

//incrementCounter to the increase value of the counter based on the Asset Type provided as input parameter by 1
func incrementCounter(APIstub shim.ChaincodeStubInterface, AssetType string) int {
	counterAsBytes, _ := APIstub.GetState(AssetType)
	counterAsset := CounterNO{}

	json.Unmarshal(counterAsBytes, &counterAsset)
	counterAsset.Counter++
	counterAsBytes, _ = json.Marshal(counterAsset)

	err := APIstub.PutState(AssetType, counterAsBytes)
	if err != nil {

		fmt.Sprintf("Failed to Increment Counter")

	}

	fmt.Println("Success in incrementing counter  %v", counterAsset)

	return counterAsset.Counter
}

// GetTxTimestampChannel Function gets the Transaction time when the chain code was executed it remains same on all the peers where chaincode executes
func (t *jutebag_supplychain) GetTxTimestampChannel(APIstub shim.ChaincodeStubInterface) (string, error) {
	txTimeAsPtr, err := APIstub.GetTxTimestamp()
	if err != nil {
		fmt.Printf("Returning error in TimeStamp \n")
		return "Error", err
	}
	fmt.Printf("\t returned value from APIstub: %v\n", txTimeAsPtr)
	timeStr := time.Unix(txTimeAsPtr.Seconds, int64(txTimeAsPtr.Nanos)).String()

	return timeStr, nil
}

func (t *jutebag_supplychain) initLedger(APIstub shim.ChaincodeStubInterface, args []string) pb.Response {
	// seed admin
	entityUser := User{Name: "admin", User_Id: "admin", Email: "admin@aidizital.com", User_Type: "admin", Address: "UK", Password: "adminpw"}
	entityUserAsBytes, errMarshal := json.Marshal(entityUser)

	if errMarshal != nil {
		return shim.Error(fmt.Sprintf("Marshal Error in user: %s", errMarshal))
	}

	errPut := APIstub.PutState(entityUser.User_Id, entityUserAsBytes)

	if errPut != nil {
		return shim.Error(fmt.Sprintf("Failed to create Entity Asset: %s", entityUser.User_Id))
	}

	fmt.Println("Added", entityUser)

	return shim.Success(nil)
}

//sign in
func (t *jutebag_supplychain) signIn(APIstub shim.ChaincodeStubInterface, args []string) pb.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expected 2 argument")
	}

	if len(args[0]) == 0 {
		return shim.Error("User Id must be provided")
	}

	if len(args[1]) == 0 {
		return shim.Error("Password must be provided")
	}

	entityUserBytes, _ := APIstub.GetState(args[0])
	if entityUserBytes == nil {
		return shim.Error("Cannot Find Entity")
	}
	entityUser := User{}
	// unmarsahlling the entity data
	json.Unmarshal(entityUserBytes, &entityUser)

	// check if password matched
	if entityUser.Password != args[1] {
		return shim.Error("Either id or password is wrong")
	}

	return shim.Success(entityUserBytes)
}

//create user
func (t *jutebag_supplychain) createUser(APIstub shim.ChaincodeStubInterface, args []string) pb.Response {

	if len(args) != 5 {
		return shim.Error("Incorrect number of arguments, Required 5 arguments")
	}

	if len(args[0]) == 0 {
		return shim.Error("Name must be provided to register user")
	}

	if len(args[1]) == 0 {
		return shim.Error("Email is mandatory")
	}

	if len(args[2]) == 0 {
		return shim.Error("User type must be specified")
	}

	if len(args[3]) == 0 {
		return shim.Error("Address must be non-empty ")
	}

	if len(args[4]) == 0 {
		return shim.Error("Password must be non-empty ")
	}

	userCounter := getCounter(APIstub, "UserCounterNO")
	userCounter++

	var comAsset = User{Name: args[0], User_Id: "User" + strconv.Itoa(userCounter), Email: args[1], User_Type: args[2], Address: args[3], Password: args[4]}

	comAssetAsBytes, errMarshal := json.Marshal(comAsset)

	if errMarshal != nil {
		return shim.Error(fmt.Sprintf("Marshal Error in JbAsset: %s", errMarshal))
	}

	errPut := APIstub.PutState(comAsset.User_Id, comAssetAsBytes)

	if errPut != nil {
		return shim.Error(fmt.Sprintf("Failed to register user: %s", comAsset.User_Id))
	}

	//TO Increment the User Counter
	incrementCounter(APIstub, "UserCounterNO")

	fmt.Println("User register successfully %v", comAsset)

	return shim.Success(comAssetAsBytes)

}
